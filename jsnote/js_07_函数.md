# 函数

形参，实参，通过this调用上下文

## 函数调用

+ 作为函数
+ 作为方法
+ 作为构造函数
+ 通过他们的call（）和apply（）方法间接调用

### 作为函数

```
var fun = function(){}

```

### 作为方法调用

无非作为一个对象的属性，然后调用执行
```
var o = {}
o.fun = function(){}
// 调用
o.fun();

```

在这个中间注意this的对象引用

```
'use strict';
var obj = {
	m: function(){
		var self = this;
		console.log(this === obj); // true， refer to obj
		fun();

		function fun(){
			console.log(this === obj); // false; refer ro global obj or undefined
			console.log(self === obj); // true ; self pointe to obj
		}
	},
	k: 'liuhui'
}
console.log(obj.k);
console.log(obj.m())

```
在实际开发的时候需要做个缓存机制，把外层的对象保留下来。

对于fun中的this指向在node环境中为“undefined”,在浏览器中this指向为“window”对象

### 作为构造函数

#### 构造函数的三部曲：

+ 构造方法
+ 定义属性
+ 原型法定义函数，这样比较的节省内存
+ 函数的继承，call，apply（用在传递数组）


通过new创建实例对象，继承自函数的prototype对象。

通过this调用上下文，this指向实例对象

关键词this指向问题，需要特别的关注，详情见原型链。

```
'use strict';
// 构造函数
function Person(name,age){
	this.name=name;
	this.age=age;
	this.common();// 自动执行函数
}

Person.prototype.out=function(){
	var self=this;
	console.log(this.name+':'+this.age);
	function dd(){
		console.log(this); // undefined 或者 全局对象（window）
		console.log(self); //  Person { name: 'lh', age: 18 },指向实例对象
		console.log(this === Person); // false
		console.log(self === Person);  // false
	};
	dd();
}
Person.prototype.common = function(){
	console.log('common sense!!');
}


var person = new Person('lh',18);
// person.out();

console.log(Person.constructor);
console.log(Person.prototype);

console.log('person');
console.log(person.constructor);
console.log(person instanceof(Person));
console.log(person.prototype);

```

### 间接调用

通过apply,call,当地一个参数为null，调用本身。

详细见（call，apply，bind方法总结）

### 闭包

见 closure

### 高级函数

#### 惰性函数


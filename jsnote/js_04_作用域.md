### js 作用域时函数作用域，不是块级作用域

这样整个函数相当于一个容器，就会存在变量作用域的提升。

```
function test(){
  console.log(i); //undefined
  var i =90;
}
test();
```

此时的undefinde 表示i已经存在，并没有复制罢了，类似于：

```
function test(){
  var i;
  console.log(i);
  var i = 90;
}
```

### 作用域中的闭包问题

```
var i = 1000;
var m = {
	i: 10 ,
	test: function(){
		console.log('test:'+this.i);
	// bibao
		return function(){
			console.log('bibao:'+ this.i);
		}

	}
}

m.test(); // test: 10

var mm = m.test();
mm();// bibao: 1000 

```

this 指向调用的对象

m.test(): this指向调用者m，调用m.i，输出10 ；

mm ＝ m.test(); 分析：

* 此时的匿名函数被return出来，返回到m函数之外了
* 此时执行mm（）：
 
 在浏览器中执行的话，输出:bibao: 1000. 类似于
 
 ```
 var i = 1000;
 function mm(){
 	console.log('bibao:'+ this.i);
 }
 ```
 
 在node中,输出为undefined,因为在node中，最外层并不是指向window对象
 
 ```
  var i = 1000;
 function mm(){
 	console.log('bibao:'+ this.i);
 }
 ```
 改为
 
 ```
 i = 1000;
 function mm(){
 	console.log('bibao:'+ this.i);
 }
 ```
 
 

















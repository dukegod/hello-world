# 执行环境

执行上下文，作用域

## 目录

* [词法作用域](#词法作用域)
* [作用域](#作用域)
* [块级作用域](#块级作用域)

### 词法作用域

描述js这们语言是如何做解析运行的原理

* 词法作用域（又称为 静态作用域）：函数的作用域在函数定义的时候就决定了。
* 动态作用域，函数的作用域是在函数调用的时候才决定的。

### 作用域

当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。

* 对象作用域
* 函数作用域

#### 变量声明

对于与变量与函数变量的不同，

##### 变量的定义

```js
console.log(a); // undefined
var a =1;
```

变量存在提升，相当于在全局作用域的最顶端定义`var a;`，此时`a`的值为`undefined`

##### 函数声明定义

第一种定义函数的方式---声明式

```js
func();

function func() {}
```

第二种定义函数的方式---函数表达式

```js
func2()
var func2 = function(){}
```

第一种可以正常运行，但是第二种不可以，因为函数表达式，`func2`变量提升了，但是在调用的时候是`undefined`，所以会报错`func2 is not function`

### 块级作用域

主要是针对 `var`, `let`, `const`做一个区别

`var` 声明作用域是可以随便越级提升的，会带来很多的问题

* 重复定义问题
* for循环调用异步函数的变量参数问题

`let`, `const` 提出一个块级作用域的概念，变量禁止重复命令，未声明先使用以及循环中的问题

const实际上保证的，是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
